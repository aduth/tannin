import pluralForms from '@tannin/plural-forms';

/**
 * Tannin constructor options.
 *
 * @typedef {Object} TanninOptions
 *
 * @property {string}   [contextDelimiter] Joiner in string lookup with context.
 * @property {Function} [onMissingKey]     Callback to invoke when key missing.
 */

/**
 * Domain metadata.
 *
 * @typedef {Object} TanninDomainMetadata
 *
 * @property {string}            [domain]       Domain name.
 * @property {string}            [lang]         Language code.
 * @property {(string|Function)} [plural_forms] Plural forms expression or
 *                                              function evaluator.
 */

/**
 * Domain translation pair respectively representing the singular and plural
 * translation.
 *
 * @typedef {[string,string]} TanninTranslation
 */

/**
 * Locale data domain. The key is used as reference for lookup, the value an
 * array of two string entries respectively representing the singular and plural
 * translation.
 *
 * @typedef {Record<string,TanninDomainMetadata|TanninTranslation>} TanninLocaleDomain
 */

/**
 * Jed-formatted locale data.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData
 */

/**
 * Default Tannin constructor options.
 *
 * @type {TanninOptions}
 */
var DEFAULT_OPTIONS = {
	contextDelimiter: '\u0004',
	onMissingKey: null,
};

/**
 * Given a specific locale data's config `plural_forms` value, returns the
 * expression.
 *
 * @example
 *
 * ```
 * getPluralExpression('nplurals=2; plural=(n != 1);') === '(n != 1)'
 * ```
 *
 * @param {string} pf Locale data plural forms.
 *
 * @return {string} Plural forms expression.
 */
function getPluralExpression(pf) {
	var parts, i, part;

	parts = pf.split(';');

	for (i = 0; i < parts.length; i++) {
		part = parts[i].trim();
		if (part.indexOf('plural=') === 0) {
			return part.substr(7);
		}
	}
}

/**
 * Tannin constructor.
 *
 * @class
 *
 * @param {TanninLocaleData} data      Jed-formatted locale data.
 * @param {TanninOptions}    [options] Tannin options.
 */
export default function Tannin(data, options) {
	var key;

	/**
	 * Jed-formatted locale data.
	 *
	 * @name Tannin#data
	 * @type {TanninLocaleData}
	 */
	this.data = data;

	/**
	 * Plural forms function cache, keyed by plural forms string.
	 *
	 * @name Tannin#pluralForms
	 * @type {Object<string,Function>}
	 */
	this.pluralForms = {};

	/**
	 * Effective options for instance, including defaults.
	 *
	 * @name Tannin#options
	 * @type {TanninOptions}
	 */
	this.options = {};

	for (key in DEFAULT_OPTIONS) {
		this.options[key] =
			options !== undefined && key in options
				? options[key]
				: DEFAULT_OPTIONS[key];
	}
}

/**
 * Returns the plural form index for the given domain and value.
 *
 * @param {string} domain Domain on which to calculate plural form.
 * @param {number} n      Value for which plural form is to be calculated.
 *
 * @return {number} Plural form index.
 */
Tannin.prototype.getPluralForm = function (domain, n) {
	var getPluralForm = this.pluralForms[domain],
		config,
		plural,
		pf;

	if (!getPluralForm) {
		config = this.data[domain][''];

		pf =
			config['Plural-Forms'] ||
			config['plural-forms'] ||
			// Ignore reason: As known, there's no way to document the empty
			// string property on a key to guarantee this as metadata.
			// @ts-ignore
			config.plural_forms;

		if (typeof pf !== 'function') {
			plural = getPluralExpression(
				config['Plural-Forms'] ||
					config['plural-forms'] ||
					// Ignore reason: As known, there's no way to document the empty
					// string property on a key to guarantee this as metadata.
					// @ts-ignore
					config.plural_forms,
			);

			pf = pluralForms(plural);
		}

		getPluralForm = this.pluralForms[domain] = pf;
	}

	return getPluralForm(n);
};

/**
 * Translate a string.
 *
 * @param {string}      domain   Translation domain.
 * @param {string|void} context  Context distinguishing terms of the same name.
 * @param {string}      singular Primary key for translation lookup.
 * @param {string=}     plural   Fallback value used for non-zero plural
 *                               form index.
 * @param {number=}     n        Value to use in calculating plural form.
 *
 * @return {string} Translated string.
 */
Tannin.prototype.dcnpgettext = function (domain, context, singular, plural, n) {
	var index, key, entry;

	if (n === undefined) {
		// Default to singular.
		index = 0;
	} else {
		// Find index by evaluating plural form for value.
		index = this.getPluralForm(domain, n);
	}

	key = singular;

	// If provided, context is prepended to key with delimiter.
	if (context) {
		key = context + this.options.contextDelimiter + singular;
	}

	entry = this.data[domain][key];

	// Verify not only that entry exists, but that the intended index is within
	// range and non-empty.
	if (entry && entry[index]) {
		return entry[index];
	}

	if (this.options.onMissingKey) {
		this.options.onMissingKey(singular, domain);
	}

	// If entry not found, fall back to singular vs. plural with zero index
	// representing the singular value.
	return index === 0 ? singular : plural;
};
